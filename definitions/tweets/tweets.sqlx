config {
  type: "incremental",
  tags: ["tweets"],
  description: "Data source table with all the collected tweets. Only tweets from MPs who were active during posting the tweet. No re-tweets. Data includes all the other possible data about the MPs as well.",
  bigquery: {
    partitionBy: "date",
    clusterBy: ["parliament_group", "party"]
  },
}

-- TODO:
-- looks like the joins are duplicating some of the tweets (very few)
-- filter out all the tweets that are not from an active MP

WITH
-- deduplicate the raw data, this part should be fine
raw_data AS (
  SELECT
    *,
    ROW_NUMBER() OVER(PARTITION BY id_str) as insert_row
    -- assign a row number to same id_strs to deduplicate the data
  FROM
    `tanelis.tweets_eu.raw_tweets`
    ${
      when(incremental(),
        `where date >= (select max(date) from ${self()}) and
                                                    CAST(id_str AS INT64) > (select MAX(CAST(id_str AS INT64)) from
                                                    ${self()})`)
    }
),
enhanced1 AS (
  SELECT
    PARSE_DATETIME('%a %b %d %H:%M:%S +0000 %Y', date_string) as date_time,
    A.*
  EXCEPT(
      full_json_string,
      source,
      is_retweet,
      -- the is_retweet dimension in the raw_data has not been collected since the start
      date_string,
      entities_user_mentions,
      entities_hashtags
    ),
    REGEXP_EXTRACT(source, r"^<a\shref.+>([^<]+)") AS device_source,
    ARRAY(
      (
        SELECT
          h.screen_name
        FROM
          UNNEST(entities_user_mentions) h
      )
    ) AS user_mentions,
    -- select as an array instead of struct
    ARRAY(
      (
        SELECT
          LOWER(h.text)
        FROM
          UNNEST(entities_hashtags) h
      )
    ) AS api_hashtags,
    -- select as an array instead of struct
    B.name,
    B.term AS parliament_term,
    B.party,
    B.parliament_group
  FROM
    raw_data A
    --resolve instead of ref: it 's not desired that updating the tweet table would by default also update the mp data tables
    LEFT JOIN ${resolve("mp_data_prod_flat")} B ON A.user_screen_name = B.screen_name
    AND A.date >= B.term_start
    AND A.date <= B.term_end
  WHERE
    insert_row = 1
),
-- join the different tweet text fields into one proper one
-- make encoded version of the mentions array
joined AS (
  SELECT
    *
  EXCEPT(
      siteUrl,
      fullText,
      full_text,
      text,
      api_hashtags,
      truncated
    ),
    `tanelis.functions.fullTweetText`(
      text,
      fullText,
      full_text,
      truncated,
      user_mentions
    ) AS full_text,
    -- it's a bit misleading to use the same full_text name here as what comes from the API. Here the dimension is fixed and all the different versions from old data are combined
    ARRAY(
      SELECT
        `tanelis.functions.encodeMention`(parliament_group, mention)
      FROM
        UNNEST(user_mentions) AS mention
    ) AS mentions_encoded,
    `tanelis.functions.extractHashtags`(truncated, api_hashtags, full_text) AS hashtags,
    `tanelis.functions.extractWords`(full_text) AS words
  FROM
    enhanced1 A
    LEFT JOIN `tanelis.tweets_eu.full_tweet_text` B ON A.id_str = REGEXP_EXTRACT(B.siteUrl, r".*status/(\d+)")
),
joined2 AS (
  SELECT
    *,
    IF (
      REGEXP_CONTAINS(full_text, r"RT\s@"),
      TRUE,
      FALSE
    ) AS is_retweet,
  FROM
    joined
)
SELECT
  *
FROM
  joined2
WHERE
  is_retweet = FALSE
  -- only original tweets in this table
