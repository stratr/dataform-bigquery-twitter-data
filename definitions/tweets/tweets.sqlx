config {
  type: "incremental",
  tags: ["tweets"],
  description: "Data source table with all the collected tweets. Only tweets from MPs who were active during posting the tweet. No re-tweets. Data includes all the other possible data about the MPs as well.",
  bigquery: {
    partitionBy: "date",
    clusterBy: ["parliament_group", "party"]
  },
}

WITH mp_data AS (
  select
    *
  except(screen_name, screen_names_old),
    array_concat(
      if(screen_name is not null, [screen_name], []),
      array(
        select
          sn
        from
          unnest(split(screen_names_old, ',')) as sn
      )
    ) as all_screen_names
  from
    ${resolve('mp_data_prod_flat')}
  where
    not (
      screen_name is null
      and screen_names_old is null
    )
),
mp_data_flattened as (
  select
    * except(all_screen_names)
  from
    mp_data,
    unnest(all_screen_names) as screen_name
),
raw_data AS (
  SELECT
    *,
    ROW_NUMBER() OVER(PARTITION BY id_str) as insert_row
    -- assign a row number to same id_strs to deduplicate the data
  FROM
    `tanelis.tweets_eu.raw_tweets`
    ${
      when(incremental(),
        `where date >= (select max(date) from ${self()}) and
                                                                        CAST(id_str AS INT64) > (select MAX(CAST(id_str AS INT64)) from
                                                                        ${self()})`)
    }
),
enhanced1 AS (
  SELECT
    PARSE_DATETIME('%a %b %d %H:%M:%S +0000 %Y', date_string) as date_time,
    A.*
  EXCEPT(
      full_json_string,
      source,
      is_retweet,
      -- the is_retweet dimension in the raw_data has not been collected since the start
      date_string,
      entities_user_mentions,
      entities_hashtags,
      insert_row
    ),
    REGEXP_EXTRACT(source, r"^<a\shref.+>([^<]+)") AS device_source,
    ARRAY(
      (
        SELECT
          h.screen_name
        FROM
          UNNEST(entities_user_mentions) h
      )
    ) AS user_mentions,
    -- select as an array instead of struct
    ARRAY(
      (
        SELECT
          LOWER(h.text)
        FROM
          UNNEST(entities_hashtags) h
      )
    ) AS api_hashtags,
    -- select as an array instead of struct
    B.name,
    B.term AS parliament_term,
    B.party,
    B.parliament_group
  FROM
    raw_data A
    --resolve instead of ref: it 's not desired that updating the tweet table would by default also update the mp data tables
    LEFT JOIN mp_data_flattened B ON (
      A.user_screen_name = B.screen_name
      AND A.date >= B.term_start
      AND A.date <= B.term_end
    )
  WHERE
    A.insert_row = 1
),
-- join the different tweet text fields into one proper one
-- make encoded version of the mentions array
joined AS (
  SELECT
    *
  EXCEPT(
      siteUrl,
      fullText,
      full_text,
      text,
      api_hashtags,
      truncated
    ),
    `tanelis.functions.fullTweetText`(
      text,
      fullText,
      full_text,
      truncated,
      user_mentions
    ) AS full_text,
    -- it's a bit misleading to use the same full_text name here as what comes from the API. Here the dimension is fixed and all the different versions from old data are combined
    ARRAY(
      SELECT
        `tanelis.functions.encodeMention`(parliament_group, mention)
      FROM
        UNNEST(user_mentions) AS mention
    ) AS mentions_encoded,
    `tanelis.functions.extractHashtags`(truncated, api_hashtags, full_text) AS hashtags,
    `tanelis.functions.extractWords`(full_text) AS words
  FROM
    enhanced1 A
    LEFT JOIN `tanelis.tweets_eu.full_tweet_text` B ON A.id_str = REGEXP_EXTRACT(B.siteUrl, r".*status/(\d+)")
),
joined2 AS (
  SELECT
    *,
    IF (
      REGEXP_CONTAINS(full_text, r"RT\s@"),
      TRUE,
      FALSE
    ) AS is_retweet,
  FROM
    joined
)
SELECT
  *
FROM
  joined2
WHERE
  is_retweet = FALSE
  and name is not null
  -- only include original tweets in this table
  -- tweets are included only from mps who were members at the time of the tweet
